# ReactDOM
ReactDOM ==> interface to the web (NB it is a package)

React itself does not know the web, the browser. React knows how to work with components, but it does not care if they contain fictional elements or HTML elements. React is just a library that manages components, state, and different components states. It cares about: state, props, context.

ReactDOM ultimately needs to bring real HTML elements to the screen.

Therfore React needs to communicate with ReactDOM: how?
React uses a concept called the **virtual DOM** (i.e. a virtual snapshot generated by React starting from the component tree): React determines how the component tree looks like and what it should look like (e.g. after a state update); and that information is then passed to ReactDOM, which computes the differences between the actual/real DOM and the virtual DOM (NB this is called **DOM diffing**), and renders them.

IMPORTANT: re-evaluating a component (which is what React does whenever the state, props, or the context change) is not the same thing as re-rendering the DOM! Instead we have to differentiate between our component (React) part and the real DOM.
**The real DOM is only updated in the places where it needs to be changed, i.e. based on the difference that the ReactDOM derived by comparing the real DOM and the virtual DOM**.
IMPORTANT: only the difference is rendered!!
So the real DOM is not changed all the time: it is changed rarely and only when needed, and this is very important for performance!!

IMPORTANT for a component function to be re-evaluated it's enough that the parent component was re-evaluated (and ofc, this does not mean that the real DOM changes). However, **if a component is re-executed, then all its child components will be re-executed and re-evaluated**. But doesn't it cost in terms of performance (imagine you have a big components tree)??
React is highly optimized for those executions and comparisons. Especially in simple apps, this will not matter. However, in bigger apps, it is advisable to optimize it.
You can tell React that it should re-execute a component under certain circumstances (e.g., the props that the component receives, have changed). If you want to do that, in the component definition (NB this syntax is valid only for functional components -- we will see howt to optimize class-based components and how to optimize them in the class-based section) export the componen wrapped with React.memo():

see DemoOutput.js
```
export default React.memo(DemoOutput)
```
IMPORTANT: go to DemoOutput.js !!!!!

https://academind.com/tutorials/reference-vs-primitive-values

In the context or React.memo() we used useCallback()
NB useCallback() is a hook that allows us to store a function across component executions:
- it allows us to tell React that we want to save a function and that this function should not be recreated with every execution
- with this, the comparison work because only one function value is stored in memory
NB so if we know for certain that a function never changes, we can useCallback to store it
NB like with useEffect, useCallback wants a second argument: an array of dependencies


# useMemo() Hook: memoize
with useCallback() you can store functions
with useMemo() you can store values across component executions, just like useCallback() does for functions

==> useMemo will have two input arguments: 1) a function, which should return the value that you want to memorize; 2) the array of dependencies, to ensure that the stored value gets updated whenever one of the dependencies changes