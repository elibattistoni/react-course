# Authentication


### Why we need authentication, and where
We need authentication in a website because some content should be protected: not all users and visitors of our website should be able to access all the content.
Protected content could be different things:
- pages: some pages should be locked if users are not authenticated (in our demo project, the profile page should only be accessible to users that are logged in, and if you are not logged in, you should not be able to visit this page)
- data: e.g. some data that you are storing in a db, some API endpoints to which your React app might be sending requests on certain pages that should be locked for non-authenticated users (e.g. in our demo project, it would be the Change Password request that we send when the "Change Password" button is clicked). And even though we lock down the profile page entirely, we also need to lock down that API endpoint to which we're sending this request, so that a request sent to this API endpoint can't succeed if the user is not logged in; we need this because if the API endpoint is not locked down, then any user who knows the URL of that endpoint could send a request to change the password of some other user. So that's why we need to restrict not only pages on our websites, but also API endpoints to which we send requests from inside our React app.

### How does authentication work
In general, authentication is a 2-step process.
1. First Step: to get access/premission for this user --> you get this access/permission by providing your credentials by logging in (after creating an account) --> this credential data is sent to some server where we can look into a db and verify your password and email combination, and if it is valid, then the server (the backend to which the request is sent) grants this permission. Once we have this permission, we can unlock certain pages on the website and/or, depending on what we need to do, use that permission to send subsequent requests to other protected resources on an API endpoint
2. Second Step: Send requests to protected resources --> so first we get the permission, then we can send more requests to other endpoints with that permission attached

However a yes vs. no response from the backend is not enough to then access protected resources like API endpoints. Why? Because yes vs. no is easy to fake

IMPORTANT The first step is good, but the response sent back by the backend needs to be more than just a yes or no. There are two commonly used methods: we can either work with **server-side sessions** or with **authentication tokens**

### Authentication with Server-side Sessions vs. with Authentication tokens
1. Server-side sessions: traditional and great approach of handling authentication --> how do they work? --> when a server grants you access, that server stores a unique identifier for your client, i.e. for this specific user who was just granted access. The server generates and stores some unique identifier for this specific client --> therefore, every visitor of a website who authenticates, gets his/her own unique identifier stored on the server --> this identifier is not just stored on the server, it is also sent back to the client --> therefore the response of the server is not just yes vs. no but it also includes the unique identifier --> this identifier is then attached to the requests that the react app sends to the backend server. This method has one disadvantage: it works great if your frontend and your backend server are tightly coupled, but if you have decoupled ends (i.e. if you have your Single Page App on server A and your backend app i.e. your rest api, on server B, then there is no tight coupling) then your backend API should probably work independently from your frontend single page app, and vice versa, or if you are building an API that should be used by many websites (e.g. google maps api), then this api will not be tightly coupled and focuse on one specific frontend, and instead it needs to be flexible --> then in these cases you don't want to store identifiers on your server, the server should be **stateless**, i.e. the server should not store data about connected clients. In this situation we should use authentication tokens
2. Authentication tokens: The general idea is: you still send some credentials (email and password) to a server and the server validates those credentials by comparing your email password combination to what's stored in the database. Then if that's valid, the server creates a permission token, which is basically just a very long string with some data encoded into that string. (the server uses some algorithm to encode some data, like the email address of the user and a bunch of other pieces of data into one string, which can be decoded back into these individual pieces of data). The token is generated by the server with a specific algorithm and very importantly, with a key, which will be used for hashing that data into a string, which is only known by the server (the key is known only by the server, not by the client) --> NB the token is not stored by the server, but it is sent back to the client and only the server knows how to create that token (because only the server knows the private key). The client (thye react app) can then use this token to attach it to future requests to protected resources on the server. And this is an approach that allows decoupling of front-end and back-end --> we are going to use this approach. NB When working with "Authentication Tokens", these tokens are typically created in the "JSON Web Token" Format (JWT). As explained in the previous lecture, those "tokens" are really just long strings which are constructed by an algorithm that encodes data into a string (with help of a private key, only known by the server).
You can learn more about JSON Web Tokens (JWTs) here: https://jwt.io/